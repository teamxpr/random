-- ============================================================
-- random.lua - High-quality PRNG for MTA:SA Lua 5.1
-- https://github.com/teamxpr/random | https://teamxpr.com
-- Generated by Claude Opus 4.6 (Anthropic)
--
-- Namespace: random.*
-- Seeded externally via random.seed(dbConnection)
-- Hot path uses xorshift128: fast, pure Lua, no DB calls.
-- ============================================================

random = {}

-- ============================================================
-- Internal state: xorshift128 (period 2^128 - 1)
-- ============================================================

local s = { 0, 0, 0, 0 }

local band = bitAnd
local bor = bitOr
local bxor = bitXor
local lshift = bitLShift
local rshift = bitRShift

local function u32(n)
	return n % 0x100000000
end

-- ============================================================
-- xorshift128 core - Marsaglia (2003)
-- ============================================================

local function xorshift128()
	local t = s[1]
	t = bxor(t, lshift(t, 11))
	t = bxor(t, rshift(t, 8))

	s[1] = s[2]
	s[2] = s[3]
	s[3] = s[4]

	local w = s[4]
	s[4] = u32(bxor(w, rshift(w, 19), t))

	return s[4]
end

-- ============================================================
-- Seeding
-- ============================================================

--- Seed the PRNG from MariaDB's CSPRNG.
-- @param connection element  your existing dbConnect handle
-- @return boolean success
function random.seed(connection)
	local qh = dbQuery(connection, "SELECT HEX(RANDOM_BYTES(16)) AS rnd")
	local result = dbPoll(qh, -1)

	if not result or #result == 0 then
		outputDebugString("Failed to seed random: no result from database", 1)
		return false
	end

	local hex = result[1].rnd

	s[1] = tonumber(string.sub(hex, 1, 8), 16)
	s[2] = tonumber(string.sub(hex, 9, 16), 16)
	s[3] = tonumber(string.sub(hex, 17, 24), 16)
	s[4] = tonumber(string.sub(hex, 25, 32), 16)

	-- xorshift128 must not have all-zero state
	if s[1] == 0 and s[2] == 0 and s[3] == 0 and s[4] == 0 then
		s[1] = 1
	end

	return true
end

-- ============================================================
-- Core API
-- ============================================================

--- Raw 32-bit unsigned random integer.
-- @return number [0, 2^32 - 1]
function random.raw32()
	return xorshift128()
end

--- Random integer in [min, max] with no modulo bias.
-- @param min number
-- @param max number
-- @return number
function random.int(min, max)
	if min > max then
		min, max = max, min
	end

	local range = max - min
	if range == 0 then
		return min
	end

	if range >= 0x100000000 then
		local hi = xorshift128()
		local lo = xorshift128()
		local val = hi * 0x100000000 + lo
		return min + (val % (range + 1))
	end

	-- Bitmask for rejection sampling
	local mask = range
	mask = bor(mask, rshift(mask, 1))
	mask = bor(mask, rshift(mask, 2))
	mask = bor(mask, rshift(mask, 4))
	mask = bor(mask, rshift(mask, 8))
	mask = bor(mask, rshift(mask, 16))

	local val
	repeat
		val = band(xorshift128(), mask)
	until val <= range

	return min + val
end

--- Random float in [0, 1).
-- @return number
function random.float()
	return xorshift128() / 0x100000000
end

--- Random float in [0, 1) with 53-bit precision.
-- @return number
function random.float53()
	local hi = xorshift128() % 0x200000
	local lo = xorshift128()
	return (hi * 0x100000000 + lo) / 0x20000000000000
end

--- Random boolean.
-- @param pTrue number|nil  probability of true (default 0.5)
-- @return boolean
function random.bool(pTrue)
	if pTrue then
		return random.float() < pTrue
	end
	return band(xorshift128(), 1) == 1
end

-- ============================================================
-- 128-bit / identifiers
-- ============================================================

--- 128-bit random as 32 hex characters.
-- @return string
function random.hex128()
	return string.format("%08X%08X%08X%08X", xorshift128(), xorshift128(), xorshift128(), xorshift128())
end

--- UUID v4.
-- @return string
function random.uuid()
	local a = xorshift128()
	local b = xorshift128()
	local c = xorshift128()
	local d = xorshift128()

	b = bor(band(b, 0xFFFF0FFF), 0x00004000)
	c = bor(band(c, 0x3FFFFFFF), 0x80000000)

	return string.format(
		"%08x-%04x-%04x-%04x-%04x%08x",
		a,
		rshift(b, 16),
		band(b, 0xFFFF),
		rshift(c, 16),
		band(c, 0xFFFF),
		d
	)
end

-- ============================================================
-- Table operations
-- ============================================================

--- Fisher-Yates shuffle (in-place, unbiased).
-- @param t table (array)
-- @return table same reference, shuffled
function random.shuffle(t)
	for i = #t, 2, -1 do
		local j = random.int(1, i)
		t[i], t[j] = t[j], t[i]
	end
	return t
end

--- Pick a random element.
-- @param t table (array)
-- @return any
function random.choice(t)
	return t[random.int(1, #t)]
end

--- Pick n unique random elements (no repeats).
-- @param t table (array)
-- @param n number
-- @return table new array
function random.sample(t, n)
	local len = #t
	local copy = {}
	for i = 1, len do
		copy[i] = t[i]
	end

	if n >= len then
		return random.shuffle(copy)
	end

	for i = len, len - n + 1, -1 do
		local j = random.int(1, i)
		copy[i], copy[j] = copy[j], copy[i]
	end

	local result = {}
	for i = len, len - n + 1, -1 do
		result[#result + 1] = copy[i]
	end
	return result
end

--- Weighted random choice.
-- @param items   table array of items
-- @param weights table array of numeric weights
-- @return any
function random.weighted(items, weights)
	local total = 0
	for i = 1, #weights do
		total = total + weights[i]
	end

	local r = random.float() * total
	local cumulative = 0
	for i = 1, #items do
		cumulative = cumulative + weights[i]
		if r < cumulative then
			return items[i]
		end
	end
	return items[#items]
end
